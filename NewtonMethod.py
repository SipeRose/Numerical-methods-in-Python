# -*- coding: utf-8 -*-
import numpy as np
#                      {x+y+xy-7=0
#                    F={
#                      {x^2+y^2+xy-13=0
X = np.array([[3.0],  [1.0]])  # точное решение 0
X1 = np.array([[1.0], [3.0]])  # точное решение 1
Xn = np.array([[0.0], [0.0]])  # начальное прибижение
Xn[0, 0] = float(input("Ввеите приближение X1: "))  # Ввод начального приближения
Xn[1, 0] = float(input("Ввеите приближение X2: "))  # Ввод начального приближения
x = Xn[0, 0]
y = Xn[1, 0]
a = 1e-6                                             # точность
Fxn = np.array([[x+y+x*y-7], [x**2+y**2+x*y-13]])    # Матрица уравнения
k = ((1+y)*(2*y+x)-(1+x)*(2*x+y))**(-1)              # 1/det(матрица Якоби)
reverseJ = k*np.array([[2*y+x, -1-x], [-y-2*x, 1+y]])  # Обратная матрица Якоби
norma = ((Xn[0, 0]-X[0, 0])**2+(Xn[1, 0]-X[1, 0])**2)**0.5  # норма для точного решения 0
norma1 = ((Xn[0, 0]-X1[0, 0])**2+(Xn[1, 0]-X1[1, 0])**2)**0.5  # норма для точного решения 1
n = 0             # число итераций
while norma > a and norma1 > a:  # точность
    for i in range(0, 2):
        Xn[i, 0] = Xn[i, 0]-(reverseJ[i, 0]*Fxn[0, 0]+reverseJ[i, 1]*Fxn[1, 0])  # метод Ньютона
    x = Xn[0, 0]
    y = Xn[1, 0]
    Fxn = np.array([[x+y+x*y-7], [x**2+y**2+x*y-13]])
    k = ((1+y)*(2*y+x)-(1+x)*(2*x+y))**(-1)                       # 1/det(матрица Якоби)
    reverseJ = k*np.array([[2*y+x, -1-x], [-y-2*x, 1+y]])           # Обратная матрица Якоби
    norma = ((Xn[0, 0]-X[0, 0])**2+(Xn[1, 0]-X[1, 0])**2)**0.5
    norma1 = ((Xn[0, 0]-X1[0, 0])**2+(Xn[1, 0]-X1[1, 0])**2)**0.5
    n = n+1                                                       # Число итераций
    print(n)
print('Число итераций =', n)
print(Xn)                                                       # Решение
